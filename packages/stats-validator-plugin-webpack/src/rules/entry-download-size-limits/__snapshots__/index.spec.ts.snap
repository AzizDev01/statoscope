// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`exclude entry object 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [
                Object {
                  "name": Object {
                    "content": "tw",
                    "flags": "",
                    "type": "regexp",
                  },
                  "type": "entry",
                },
              ],
              "global": Object {
                "maxSize": 1,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"one\\": Download size of assets is 0.44 kb. It's over the 0.00 kb limit",
    "related": Array [
      Object {
        "id": "one",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`exclude entry regexp 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [
                Object {
                  "name": Object {
                    "content": "tw",
                    "flags": "",
                    "type": "regexp",
                  },
                  "type": "entry",
                },
              ],
              "global": Object {
                "maxSize": 1,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"one\\": Download size of assets is 0.44 kb. It's over the 0.00 kb limit",
    "related": Array [
      Object {
        "id": "one",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`exclude entry string 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [
                Object {
                  "name": Object {
                    "content": "two",
                    "type": "string",
                  },
                  "type": "entry",
                },
              ],
              "global": Object {
                "maxSize": 1,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"one\\": Download size of assets is 0.44 kb. It's over the 0.00 kb limit",
    "related": Array [
      Object {
        "id": "one",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`exclude no exclude 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [
                Object {
                  "name": Object {
                    "content": "foooo",
                    "flags": "",
                    "type": "regexp",
                  },
                  "type": "entry",
                },
              ],
              "global": Object {
                "maxSize": 1,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"one\\": Download size of assets is 0.44 kb. It's over the 0.00 kb limit",
    "related": Array [
      Object {
        "id": "one",
        "type": "entry",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [
                Object {
                  "name": Object {
                    "content": "foooo",
                    "flags": "",
                    "type": "regexp",
                  },
                  "type": "entry",
                },
              ],
              "global": Object {
                "maxSize": 1,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"two\\": Download size of assets is 8.53 kb. It's over the 0.00 kb limit",
    "related": Array [
      Object {
        "id": "two",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`maxAsyncSize global 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [],
              "global": Object {
                "maxAsyncSize": 100,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"two\\": Download size of async assets is 0.13 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "two",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`maxAsyncSize not match - global 1`] = `Array []`;

exports[`maxAsyncSize not match - override global 1`] = `Array []`;

exports[`maxAsyncSize override global 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [
                Object {
                  "limits": Object {
                    "maxAsyncSize": 100,
                  },
                  "name": Object {
                    "content": ".+",
                    "flags": "",
                    "type": "regexp",
                  },
                },
              ],
              "exclude": Array [],
              "global": Object {
                "maxAsyncSize": 100000,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"two\\": Download size of async assets is 0.13 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "two",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`maxAsyncSize with useCompressedSize = false 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [],
              "global": Object {
                "maxAsyncSize": 100,
              },
              "useCompressedSize": false,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"two\\": Download size of async assets is 0.14 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "two",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`maxInitialSize global 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [],
              "global": Object {
                "maxInitialSize": 100,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"one\\": Download size of initial assets is 0.44 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "one",
        "type": "entry",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [],
              "global": Object {
                "maxInitialSize": 100,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"two\\": Download size of initial assets is 8.40 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "two",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`maxInitialSize not match - global 1`] = `Array []`;

exports[`maxInitialSize not match - override global 1`] = `Array []`;

exports[`maxInitialSize override global 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [
                Object {
                  "limits": Object {
                    "maxInitialSize": 100,
                  },
                  "name": Object {
                    "content": ".+",
                    "flags": "",
                    "type": "regexp",
                  },
                },
              ],
              "exclude": Array [],
              "global": Object {
                "maxInitialSize": 100000,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"one\\": Download size of initial assets is 0.44 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "one",
        "type": "entry",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [
                Object {
                  "limits": Object {
                    "maxInitialSize": 100,
                  },
                  "name": Object {
                    "content": ".+",
                    "flags": "",
                    "type": "regexp",
                  },
                },
              ],
              "exclude": Array [],
              "global": Object {
                "maxInitialSize": 100000,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"two\\": Download size of initial assets is 8.40 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "two",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`maxInitialSize with useCompressedSize = false 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [],
              "global": Object {
                "maxInitialSize": 100,
              },
              "useCompressedSize": false,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"one\\": Download size of initial assets is 0.78 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "one",
        "type": "entry",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [],
              "global": Object {
                "maxInitialSize": 100,
              },
              "useCompressedSize": false,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"two\\": Download size of initial assets is 11.97 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "two",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`maxSize global 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [],
              "global": Object {
                "maxSize": 100,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"one\\": Download size of assets is 0.44 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "one",
        "type": "entry",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [],
              "global": Object {
                "maxSize": 100,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"two\\": Download size of assets is 8.53 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "two",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`maxSize not match - global 1`] = `Array []`;

exports[`maxSize not match - override global 1`] = `Array []`;

exports[`maxSize override global 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [
                Object {
                  "limits": Object {
                    "maxSize": 100,
                  },
                  "name": Object {
                    "content": ".+",
                    "flags": "",
                    "type": "regexp",
                  },
                },
              ],
              "exclude": Array [],
              "global": Object {
                "maxSize": 100000,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"one\\": Download size of assets is 0.44 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "one",
        "type": "entry",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [
                Object {
                  "limits": Object {
                    "maxSize": 100,
                  },
                  "name": Object {
                    "content": ".+",
                    "flags": "",
                    "type": "regexp",
                  },
                },
              ],
              "exclude": Array [],
              "global": Object {
                "maxSize": 100000,
              },
              "useCompressedSize": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"two\\": Download size of assets is 8.53 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "two",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;

exports[`maxSize with useCompressedSize = false 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [],
              "global": Object {
                "maxSize": 100,
              },
              "useCompressedSize": false,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"one\\": Download size of assets is 0.78 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "one",
        "type": "entry",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "deserialize": Object {
          "content": "
              $theContext: context;
              {
                context: {
                  params: {
                    exclude: $theContext.params.exclude.(deserializeExclude()),
                    byName: $theContext.params.byName.({ name: name.deserializeStringOrRegexp(), limits }),
                    global: $theContext.params.global,
                    useCompressedSize: $theContext.params.useCompressedSize,
                  },
                }
              }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $params: #.params;
  $useCompressedSize: [$params.useCompressedSize, true].useNotNullish();
  $getSizeByChunks: => files.(getAssetSize($$, $useCompressedSize!=false)).reduce(=> size + $$, 0);
  
  $input.compilations
  .exclude({
    exclude: $params.exclude.[type='compilation'].name,
    get: <name>,
  })
  .({
    $compilation: $;
    $compilation,
    entrypoints: entrypoints
    .exclude({
      exclude: $params.exclude.[type='entry'].name,
      get: <name>,
    })
    .({
      $entry: $;
      $matchedRule: $params.byName.[$entry.name.isMatch(name)].pick(-1).limits;
      $rule: {
        maxSize: [$matchedRule.maxSize, $params.global.maxSize].useNotNullish(),
        maxInitialSize: [$matchedRule.maxInitialSize, $params.global.maxInitialSize].useNotNullish(),
        maxAsyncSize: [$matchedRule.maxAsyncSize, $params.global.maxAsyncSize].useNotNullish(),
      };
      $chunks: ($entry.data.chunks + $entry.data.chunks..children);
      $initialChunks: $chunks.[initial];
      $asyncChunks: $chunks.[not initial];
      $size: $chunks.$getSizeByChunks($compilation.hash);
      $initialSize: $initialChunks.$getSizeByChunks($compilation.hash);
      $asyncSize: $asyncChunks.$getSizeByChunks($compilation.hash);
      
      $entry,
      $chunks,
      $initialChunks,
      $asyncChunks,
      $rule,
      $size,
      $initialSize,
      $asyncSize,
      sizeOK: $rule.maxSize = null ? true : $size <= $rule.maxSize,
      initialSizeOK: $rule.maxInitialSize = null ? true : $initialSize <= $rule.maxInitialSize,
      asyncSizeOK: $rule.maxAsyncSize = null ? true : $asyncSize <= $rule.maxAsyncSize,
    })
    .[not (sizeOK and initialSizeOK and asyncSizeOK)]
  })
  .[entrypoints]",
        "serialized": Object {
          "context": Object {
            "params": Object {
              "byName": Array [],
              "exclude": Array [],
              "global": Object {
                "maxSize": 100,
              },
              "useCompressedSize": false,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "Entry \\"two\\": Download size of assets is 12.10 kb. It's over the 0.10 kb limit",
    "related": Array [
      Object {
        "id": "two",
        "type": "entry",
      },
    ],
    "type": "error",
  },
]
`;
