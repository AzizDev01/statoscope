// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`matches 1`] = `
Array [
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "content": Array [
          "Instances:",
          "- node_modules/foo  1.0.0",
        ],
        "type": "text",
      },
      Object {
        "content": Array [
          "Instances:",
          "- node_modules/foo  1.0.0",
        ],
        "type": "tty",
      },
      Object {
        "deserialize": Object {
          "content": "
                $theContext: context;
                {
                  context: {
                    target: {
                      name: $theContext.target.name.deserializeStringOrRegexp(),
                      version: $theContext.target.version,
                    },
                    exclude: $theContext.exclude.(deserializeStringOrRegexp),
                  }
                }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $target: #.target;
  $exclude: #.exclude;
  
  $input.group(<compilations>)
  .({file: value.pick(), compilation: key})
  .exclude({
    exclude: $exclude.[type='compilation'].name,
    get: <compilation.name>,
  })
  .({
    ...$,
    packages: compilation.nodeModules
    .[name.isMatch($target.name)]
    .({
      $package: $;
      $package,
      instances: instances
        .[
          $passVersion: (not $target.version or not version).bool();
          $passVersion or version.semverSatisfies($target.version)
        ].sort(isRoot desc, path.size() asc)
    })
  })
  .[packages.instances]",
        "serialized": Object {
          "context": Object {
            "exclude": Array [],
            "target": Object {
              "name": Object {
                "content": "foo",
                "type": "string",
              },
              "version": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "foo@1.0.0 should not be used",
    "related": Array [
      Object {
        "id": "foo",
        "type": "package",
      },
      Object {
        "id": "node_modules/foo",
        "type": "package-instance",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "content": Array [
          "Instances:",
          "- node_modules/foo  1.0.0",
        ],
        "type": "text",
      },
      Object {
        "content": Array [
          "Instances:",
          "- node_modules/foo  1.0.0",
        ],
        "type": "tty",
      },
      Object {
        "deserialize": Object {
          "content": "
                $theContext: context;
                {
                  context: {
                    target: {
                      name: $theContext.target.name.deserializeStringOrRegexp(),
                      version: $theContext.target.version,
                    },
                    exclude: $theContext.exclude.(deserializeStringOrRegexp),
                  }
                }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $target: #.target;
  $exclude: #.exclude;
  
  $input.group(<compilations>)
  .({file: value.pick(), compilation: key})
  .exclude({
    exclude: $exclude.[type='compilation'].name,
    get: <compilation.name>,
  })
  .({
    ...$,
    packages: compilation.nodeModules
    .[name.isMatch($target.name)]
    .({
      $package: $;
      $package,
      instances: instances
        .[
          $passVersion: (not $target.version or not version).bool();
          $passVersion or version.semverSatisfies($target.version)
        ].sort(isRoot desc, path.size() asc)
    })
  })
  .[packages.instances]",
        "serialized": Object {
          "context": Object {
            "exclude": Array [],
            "target": Object {
              "name": Object {
                "content": "foo",
                "type": "string",
              },
              "version": "^1.0.0 || ^2.0.0",
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "foo@1.0.0 should not be used",
    "related": Array [
      Object {
        "id": "foo",
        "type": "package",
      },
      Object {
        "id": "node_modules/foo",
        "type": "package-instance",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "content": Array [
          "Instances:",
          "- node_modules/foo  1.0.0",
        ],
        "type": "text",
      },
      Object {
        "content": Array [
          "Instances:",
          "- node_modules/foo  1.0.0",
        ],
        "type": "tty",
      },
      Object {
        "deserialize": Object {
          "content": "
                $theContext: context;
                {
                  context: {
                    target: {
                      name: $theContext.target.name.deserializeStringOrRegexp(),
                      version: $theContext.target.version,
                    },
                    exclude: $theContext.exclude.(deserializeStringOrRegexp),
                  }
                }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $target: #.target;
  $exclude: #.exclude;
  
  $input.group(<compilations>)
  .({file: value.pick(), compilation: key})
  .exclude({
    exclude: $exclude.[type='compilation'].name,
    get: <compilation.name>,
  })
  .({
    ...$,
    packages: compilation.nodeModules
    .[name.isMatch($target.name)]
    .({
      $package: $;
      $package,
      instances: instances
        .[
          $passVersion: (not $target.version or not version).bool();
          $passVersion or version.semverSatisfies($target.version)
        ].sort(isRoot desc, path.size() asc)
    })
  })
  .[packages.instances]",
        "serialized": Object {
          "context": Object {
            "exclude": Array [],
            "target": Object {
              "name": Object {
                "content": "foo",
                "type": "string",
              },
              "version": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "foo@1.0.0 should not be used",
    "related": Array [
      Object {
        "id": "foo",
        "type": "package",
      },
      Object {
        "id": "node_modules/foo",
        "type": "package-instance",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "content": Array [
          "Instances:",
          "- node_modules/foo  1.0.0",
        ],
        "type": "text",
      },
      Object {
        "content": Array [
          "Instances:",
          "- node_modules/foo  1.0.0",
        ],
        "type": "tty",
      },
      Object {
        "deserialize": Object {
          "content": "
                $theContext: context;
                {
                  context: {
                    target: {
                      name: $theContext.target.name.deserializeStringOrRegexp(),
                      version: $theContext.target.version,
                    },
                    exclude: $theContext.exclude.(deserializeStringOrRegexp),
                  }
                }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $target: #.target;
  $exclude: #.exclude;
  
  $input.group(<compilations>)
  .({file: value.pick(), compilation: key})
  .exclude({
    exclude: $exclude.[type='compilation'].name,
    get: <compilation.name>,
  })
  .({
    ...$,
    packages: compilation.nodeModules
    .[name.isMatch($target.name)]
    .({
      $package: $;
      $package,
      instances: instances
        .[
          $passVersion: (not $target.version or not version).bool();
          $passVersion or version.semverSatisfies($target.version)
        ].sort(isRoot desc, path.size() asc)
    })
  })
  .[packages.instances]",
        "serialized": Object {
          "context": Object {
            "exclude": Array [],
            "target": Object {
              "name": Object {
                "content": "^foo",
                "flags": "",
                "type": "regexp",
              },
              "version": undefined,
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "foo@1.0.0 should not be used",
    "related": Array [
      Object {
        "id": "foo",
        "type": "package",
      },
      Object {
        "id": "node_modules/foo",
        "type": "package-instance",
      },
    ],
    "type": "error",
  },
  Object {
    "compilation": "718159f8e48dcecd92c9",
    "details": Array [
      Object {
        "content": Array [
          "Instances:",
          "- node_modules/foo  1.0.0",
        ],
        "type": "text",
      },
      Object {
        "content": Array [
          "Instances:",
          "- node_modules/foo  1.0.0",
        ],
        "type": "tty",
      },
      Object {
        "deserialize": Object {
          "content": "
                $theContext: context;
                {
                  context: {
                    target: {
                      name: $theContext.target.name.deserializeStringOrRegexp(),
                      version: $theContext.target.version,
                    },
                    exclude: $theContext.exclude.(deserializeStringOrRegexp),
                  }
                }",
          "type": "query",
        },
        "filename": "input.json",
        "query": "
  $input: resolveInputFile();
  $target: #.target;
  $exclude: #.exclude;
  
  $input.group(<compilations>)
  .({file: value.pick(), compilation: key})
  .exclude({
    exclude: $exclude.[type='compilation'].name,
    get: <compilation.name>,
  })
  .({
    ...$,
    packages: compilation.nodeModules
    .[name.isMatch($target.name)]
    .({
      $package: $;
      $package,
      instances: instances
        .[
          $passVersion: (not $target.version or not version).bool();
          $passVersion or version.semverSatisfies($target.version)
        ].sort(isRoot desc, path.size() asc)
    })
  })
  .[packages.instances]",
        "serialized": Object {
          "context": Object {
            "exclude": Array [],
            "target": Object {
              "name": Object {
                "content": "foo",
                "type": "string",
              },
              "version": "^1.0.0 || ^2.0.0",
            },
          },
        },
        "type": "discovery",
      },
    ],
    "filename": "input.json",
    "message": "foo@1.0.0 should not be used",
    "related": Array [
      Object {
        "id": "foo",
        "type": "package",
      },
      Object {
        "id": "node_modules/foo",
        "type": "package-instance",
      },
    ],
    "type": "error",
  },
]
`;

exports[`not matches 1`] = `Array []`;
